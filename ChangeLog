2004-11-01   Darren Duncan <perl@DarrenDuncan.net>

	* Release 0.47.

	* New code file versions are: Routine.pm v0.47 and en.pm v0.17.

	* This release mainly serves to merge two previously distinct modules into
	one; SQL::Routine::ByTree has been merged into SQL::Routine, and no longer
	exists as its own entity.  However, the code that was ByTree.pm has been
	rewritten in the process.  Similarly, SQL::Routine::ByTree::L::en was
	merged into SQL::Routine::L::en.  The details of this merger are given
	below, but simply in terms of new functionality being added to Routine.pm.

	* Renamed the *parent_node*() methods to *pp_node*(); this affected
	Routine.pm and en.pm and the test suite.

	* Added new Node method get_first_candidate_pp_node_attribute_name().

	* Added 7 new functions or methods that should assist more rapid
	development of code that uses SQL::Routine, at the cost that the code would
	run a bit slower (SQL::Routine has to search for info behind the scenes
	that it would otherwise get from you).  These methods are implemented as
	wrappers over other SQL::Routine methods, and allow you to accomplish with
	one method call what otherwise requires about 4-10 method calls, meaning
	your code base is significantly smaller (unless you implement your own
	simplifying wrapper functions, which is recommended in some situations).
	These 2 can be invoked on any class name or object: build_lonely_node(),
	build_container().  These 5 can be invoked only on an object: build_node(),
	build_child_node(), build_child_nodes(), build_child_node_tree(),
	build_child_node_trees(); the last 2 of these 5 correspond the most to the
	old 4 ByTree.pm create_[child_]node_tree[s]() methods, and take all of the
	same input that they did.  Added 6 new message keys to en.pm that
	correspond to the 7 added methods.

	* Corrected a bug in Routine.pm where the 'catalog_instance' Node attribute
	'server_domain' was mis-named 'server_scalar_domain'.

	* Small corresponding change in Language.pod and Routine.pm: Added a
	distinct value constraint on each of "[table|view]_field.row_field"; this 
	was the only change to Language.pod.

	* Split up the tester module t_SQL_Routine.pm into two more specialized
	files, which SQL_Routine.t invokes: t_SRT_Circular.pm, t_SRT_Verbose.pm;
	none of the module test code itself was changed during the split.

	* Added a third tester module t_SRT_Terse.pm, which SQL_Routine.t invokes;
	it is similar in structure to t_SRT_Verbose.pm but it exclusively uses the
	new build_*() to produce the model.  This tester module is a modified 
	version of the t_SQL_Routine_ByTree.pm that came with SQL::Routine::ByTree.
	The new test count goes from 1..9, up from 1..6.

	* The code added to Routine.pm wasn't identical to that removed from
	ByTree.pm; these are the main changes:  1. ByTree.pm called
	assert_deferrable_constraints() immediately after each Node was built;
	Routine.pm does not.  2. ByTree.pm always put the new Nodes in a Container
	(or tried to and could possibly have died on a Perl error); Routine.pm only
	does in specific situations.  3. ByTree.pm never generated Node ids;
	Routine.pm does in specific situations.

2004-10-29   Darren Duncan <perl@DarrenDuncan.net>

	* Release 0.46.

	* New code file versions are: Routine.pm v0.46 and en.pm v0.16.

	* This is a major release, with multiple significant data-dictionary,
	documentation, and test suite changes, but almost no changes to the code
	proper.  Most changes were in Routine.pm, Language.pod, and
	t_SQL_Routine.pm.  A few changes were made to en.pm or API_C.pod.

	* Renamed all Node-ref attributes that are primary-parent candidates so
	that their names start with "pp_".  Also renamed any related variable names
	and property names and message key names in a similar fashion.  The Node
	property 'p_node_atnm' is now 'pp_node_atnm', in both Routine.pm and
	API_C.pod; that was the only change to API_C.pod.  Six message keys were
	renamed in Routine.pm and en.pm; that was the only change to en.pm.  Also
	changed the order of a few primary-parent attribute declarations so that
	any which are self-references always appear first in the list.

	* Eliminated the deprecated 'view_hierarchy' Node type; you should use
	the already supported SQL:2003 recursive correlated subqueries instead.

	* Replaced most of the 'view_type' enumerated type values; the new list is
	[ALIAS, JOINED, GROUPED, COMPOUND, INSERT, UPDATE, DELETE]; the old list
	was [MATCH, SINGLE, MULTIPLE, COMPOUND, SUBQUERY, RECURSIVE].  Removed the
	'view' Node attribute 'match_all_cols'.  Added the 'view' Node attribute
	'recursive'.  Added the new Node type 'view_compound_elem', which specifies
	operands for compound views explicitly, just as 'view_join' explicitly gave
	joined view operands; as a result of this change, it is now possible for a
	compound view to have subqueries; the subquery-defining views are not
	included as compound operands implicitly due to their presence.

	* Reversed all code and documentation changes made by release 0.44 that
	removed the 'elements' level-2 pseudo-Node; it is now useful again.  The
	restored documentation was also cleaned up.

	* Renamed the 'simple_data_type' enumerated type to 'simple_scalar_type'.

	* Split the 'domain' Node type into the 'scalar_data_type' and
	'scalar_domain' Node types; 'scalar_data_type' Nodes are the same as the
	old 'domain' Nodes (complete with '*_opt' child Nodes) except that they
	live directly under 'elements', and not other Nodes; each 'scalar_domain'
	Node (optional) simply declares a schema object that is defined by a
	'scalar_data_type' Node, and can live where the old 'domain' Nodes lived. 
	As a result of this change, you now can choose whether each individual data
	type becomes a named schema object of its own or not.  Updated any other
	Node type attributes that referenced 'domain' Nodes so that each one can
	choose whether to reference a 'data_type' or 'domain' Node.

	* Updated most Node types with new or changed attributes so that they are
	now almost as saavy with collection data types as they are with scalar data
	types.  Routine variables and arguments and return values can now properly
	define all of these container types: SCALAR, SC_ARY, ROW, RW_ARY.  As can
	routine statements and expressions, and view expressions, and correlated
	view arguments.  Added 3 new Node types 'row_data_type' (with child
	'row_data_type_field') and 'row_domain'.  The general features and living
	arrangements of the 'row_*' Node types correspond to the 3 'scalar_*' Node
	types.  Most Node types that referenced domains before now reference the
	row type definitions.

	* Changed how the core column definitions for tables and views are done;
	now a 'row_data_type' will be created for each distinct table and view,
	which the 'table' or 'view' Node references in a new attribute-pair; this
	row_data_type declares the names and scalar data types for a table's or
	view's complete column set.  All other table or view related Node types now
	reference 'row_data_type_field' Nodes instead of '[table|view]_col' Nodes,
	since they are the core column definitions now.  Additional details for
	columns are still stored in reduced versions of the old two Node types,
	which have been renamed to '[table|col]_field'; these reduced Node types
	are no longer mandatory, and only need to be used for their added value. 
	All other Node types and attributes named '[*_|]col[|_*]' were renamed to
	'[*_|]field[|_*]', as were any similarly named code variables or functions.

	* Updated the 'view_src[|_field]' Nodes so that you now have 5 options for
	sources rather than 2; a source can match a table or a view as before, or
	it can match a local routine arg or var or correlated view arg that has a
	ROW or RW_ARY type; all 5 of these are conceptually a row set.

	* Changed how standard views for 'SELECT' and 'INSERT' statements are
	defined; now every row is selected or inserted as a single unit, either
	into or from row variables that are declared with the same 'row_data_type'
	as the view; the 4 new 'view' Node attributes
	'[set|ins]_p_routine_[arg|var]' say where to either select into or insert
	from.  Renamed the standard function 'SELECT_INTO' to 'SELECT'; the
	'SELECT' and 'INSERT' standard functions are overloaded to select or insert
	either a single row or a full rowset; what they do is controlled by the
	container type of the aforementioned source/target variable that is
	associated with the view; a 'ROW' will cause a single row, while a 'RW_ARY'
	will cause multiple rows.  The way that views for 'UPDATE' or 'DELETE'
	statements work is unchanged; they continue to be controlled through scalar
	variables associated with the views in their 'SET' or 'WHERE' SQL clauses.
	The 2 view_field attributes that were used by "select into" are now gone.

	* Renamed any table index attributes and related variables from
	'[*_|]ind[|_*]' to '[*_|]index[|_*]'.

	* Renamed the 'view_join' attribute 'join_type' to 'join_op'.

	* Multiple updates to t_SQL_Routine.pm.  All of the domain declarations
	were replaced with data-type declarations.  The table declaration now has a
	row_data_type declaration split out from it.  The "fetch_all_persons"
	routine now does an ordinary SELECT and returns a RW_ARY, rather than the
	more complicated process of declaring, opening, and returning a CURSOR;
	that is more like how people would often accomplish the task in real life. 
	The "insert_a_person" also had a lot of changes, where it lost about half
	of its size; the new version takes a single ROW argument instead of four
	SCALAR arguments, and the new INSERT built-in takes that as a single unit. 
	Mostly correspondence to all the attribute name changes, besides.  The
	SYNOPSIS in Routine.pm also had similar changes.

	* Cleaned up the LANGUAGE CONCEPT STRUCTURE in Language.pod to remove
	and/or correct some redundant details.  Removed a large chunk of antiquated
	documentation from the 'view_expr' Node type.  Also, some other small
	documentation cleanups in Language.pod and Routine.pm.

2004-10-26   Darren Duncan <perl@DarrenDuncan.net>

	* Release 0.45.

	* New code file versions are: Routine.pm v0.45.

	* This release saw multiple data-dictionary, documentation, and test suite
	changes, but zero changes to the code proper.  All changes were in
	Routine.pm, Language.pod, and t_SQL_Routine.pm.  No changes were made to
	en.pm or API_C.pod.

	* In Routine.pm, rewrote the DESCRIPTION documentation.  Specifically, all
	but the first paragraph of the old DESCRIPTION was moved into a new section
	titled MATTERS OF PORTABILITY AND FEATURES.  The new DESCRIPTION is
	completely new, and better describes the purpose, features, strengths, and
	distinctiveness of this module, than the old documentation did.

	* Multiple corresponding data-dictionary changes in Language.pod and
	Routine.pm.  Added new 'routine_context' Node type that is conceptually a
	special-purpose 'routine_arg'; they are optional, and each 'routine' can
	have only one.  Added new 'standard_routine_context' enumerated type which
	is to standard routines what the new Node type is for user-defined
	routines.  Updated the existing standard routine specs to separate the
	'context' and 'args'.  Added new Node attributes to [view_arg,
	routine_stmt, routine_expr] so that the new 'context' for standard or
	user-defined routines can be referenced.  Added related constraints.

	* Changed the nature of how CONN/CONN_CX (db connection context) is
	declared, used, and changed, so that it is like CURSOR/CURSOR_CX.  Now,
	most details of a db connection context are defined when the variable that
	holds it is declared.  A CONN now has two distinct states, being 'open' or
	'closed', which it must be explicitly set to using CATALOG_OPEN() and
	CATALOG_CLOSE(); a CONN is no longer implicitly open simply by its
	existence; a brand new CONN variable starts out closed.  As a result of
	this change, you can now declare a connection context in a different
	user-defined routine than you open it in; also, you can now close and
	reopen a database connection multiple times with the same CONN, rather than
	having to make a new CONN for each time (it is also now easier to represent
	cached database connections).

	* Updated the 'container_type' enumerated type to add new list elements:
	ROW, SC_ARY, RW_ARY.  These correspond to commonly used composite data
	types.  A 'ROW' corresponds to the SQL:2003 'ROW' and is a collection of
	named and typed scalar values; it is like a single table row, or a Perl
	hash.  Both 'SC_ARY' and 'RW_ARY' correspond to the SQL:2003 'ARRAY'; the
	first is an ordered list of 'SCALAR'; the second, an ordered list of 'ROW'.
	The rest of SQL::Routine is not yet updated to take advantage of the new
	types; that should happen in release 0.46.

	* Renamed all occurances of [LOGIN_USER|login_user] to
	[LOGIN_NAME|login_name]; this affects the CATALOG_OPEN() srt and these 
	Node types: catalog_instance, catalog_link_instance.

	* For all Node types that have a 'name' attribute, except 'user', that
	attribute is now always-mandatory.  In this release, that affects only
	these Node types (the rest were MA previously): catalog, application,
	data_storage_product, data_link_product, catalog_instance,
	application_instance.

	* Fixed bugs in Routine.pm where Node attribute types did not match their
	Language.pod documentation: table_col.default_val is 'misc' (not 'cstr');
	routine_expr.valf_literal is 'misc' (not 'cstr').

	* In Language.pod, added paragraph for the view_arg Node that explains
	correlated vs uncorrelated subqueries.  Also updated the features list. 
	Also updated the documented meaning of the table_col's "mandatory" attr.

	* Multiple updates to t_SQL_Routine.pm.  Split the user-defined routine
	"open_db_conn" into itself and "declare_db_conn", added "close_db_conn". 
	Most other changes correspond to the the above-mentioned feature changes,
	such as context Nodes and CONN changes.  More Nodes now have their 'name'
	set.  Also rearranged the order in which a few Node attributes are set, to
	match the order they appear within the Node.  The SYNOPSIS in Routine.pm 
	also had a few similar changes, but most of those were small.

2004-10-16   Darren Duncan <perl@DarrenDuncan.net>

	* Release 0.44.

	* New code file versions are: Routine.pm v0.44.

	* This is a major release, with multiple significant data-dictionary,
	documentation, and test suite changes, but almost no changes to the code
	proper.  All changes were in Routine.pm, Language.pod, and
	t_SQL_Routine.pm.  No changes were made to en.pm or API_C.pod.

	* Added 4 new enumerated value types: container_type, exception_type,
	standard_routine, standard_routine_arg.  Removed 6 old enumerated value
	types: basic_expr_type, standard_func, basic_var_type, basic_stmt_type,
	standard_proc, command_type.  The 4 new types are mostly recombined
	replacements for the old 6 ones, though some of the old were simply
	superfluous.  exception_type is completely new.  container_type corresponds
	to basic_var_type plus the return-values documentation section in
	command_type plus the 'LIST' of basic_expr_type.  standard_routine is
	mostly the 3-way combination of command_type, standard_proc, standard_func,
	plus 'CAST' and 'RETURN' of basic_[expr|stmt]_type.  The majority of
	basic_[expr|stmt]_type was simply dropped since the info they gave
	duplicated what could be known by reading other attributes in
	[view|routine]_expr Nodes, which mostly corresponded 1:1.

	* Removed the 'command' and 'command_arg' Node types, which were only meant
	to be a temporary stop-gap feature anyway.  Their functionality has been
	integrated into the standard 'routine[|*]' Nodes, which can now embed
	built-in routine calls for all kinds of functionality, including queries,
	DML, DDL, and connection management.

	* Eliminated the 'elements' level 2 pseudo-Node, which hasn't been used for
	awhile; only 4 are left: 'blueprints', 'tools', 'sites', 'circumventions'.

	* All built-in standard routines now take named arguments rather than
	positional ones, just like user-defined routines; they can now all be used
	in the same ways.  In addition, it is now standard practice for any
	built-in routine to indicate failure by throwing an exception; the routine
	is assumed to have succeeded if it doesn't do this.

	* All schema object types (domains, sequences, tables, views, routines) can
	now be defined as either server/database-side or application-side (the
	first 3 were added).  Defining a table on the application-side is now the
	official way to make a "temporary table"; there is no 'table' Node
	attribute for that.

	* There is now more detailed documentation for many built-in routines,
	including what their arguments are, side-effects of calling them, and
	exceptions they may throw.

	* Added the commonly used 'ANSEL' to the 'char_enc_type' enum list.

	* Added a 'single_schema' attribute to 'catalog' Nodes.

	* Many small clean-ups and standardization with the order of attribute
	Nodes.  Now, all primary-parent candidate attributes always appear at the
	top of the list, below 'id'; then comes the 'name' attribute if there is
	one; then come the other attributes, starting with any always-mandatory or
	'type' ones, and grouped by functional relation.  Renamed and regrouped
	most view_expr and routine_expr attributes; the ones indicating
	correspondence such as what cols or args to *set* or *pass to* go first,
	and the ones indicating where a value comes from are below them; the latter
	group all start with 'valf_' for "value from".  The routine_stmt Node was
	simplified, with some details stored in routine_expr Nodes instead.  A set
	of 8 new attributes in routine_expr, which start with 'actn_' (for "act
	on") are used mainly with former 'CREATE_' (etc) standard routines.  The 
	new attribute names should be more descriptive than the old ones.

	* In Routine.pm, updated Node.assert_deferrable_constraints() in how the
	"Local Attribute Dependencies List" constraints are implemented so that
	depended-on attributes of all 3 major types are handled with common code.

	* Rewrote major parts of the SYNOPSIS in Routine.pm so that it provides a 
	complete but simple working example, rather than just a few lines plus 
	a reference to another file.

	* Updated sigificant chunks of t_SQL_Routine.pm to give a more complete
	semblence of working examples.

	* Replaced all documentation occurances of "SQL-2003" with "SQL:2003".

	* Updated all code that referenced module version numbers so that those
	numbers are now quoted in strings rather than being bare numbers.  In the
	*.pm files, this affected only the "use" strings, since each $VERSION was
	already declared as a string.  In the *.t files, the "use" strings.  In the
	Makefile.PL, each PREREQ_PM item was updated.

	* A few other small changes and fixes.

2004-10-04   Darren Duncan <perl@DarrenDuncan.net>

	* Release 0.43.

	* This is the first version of the SQL-Routine distribution under that
	name, which follows the official registration of SQL::Routine with the Perl
	5 Module List.  The core module has been renamed to SQL::Routine from
	SQL::SyntaxModel, its previous name; all similarly named modules and files
	were correspondingly renamed.  All name-related strings, both in code and
	documentation, were updated as follows: "SyntaxModel" -> "Routine", "SSM"
	-> "SRT", "SQLSM" -> "SQLRT", "sqlsm" -> "sqlrt".

	* New code file versions are: Routine.pm v0.43 and en.pm v0.15.

	* Updated external dependencies on Locale::KeyedText to v1.00.

	* Changed the NAME of Routine.pm to "Specify all database tasks with SQL
	routines" from "An abstract syntax tree for all types of SQL".

	* Aside from the name references, version numbers, and dependencies, no
	changes were made to any code or documentation between SQL-SyntaxModel-0.42
	and SQL-Routine-0.43.  A significant update to the main documentation is 
	planned for v0.44 which reflects the module's current functional domain.

	* For historical posterity, here is this distribution's file manifest:

		ChangeLog
		INSTALL
		lib/SQL/Routine.pm
		lib/SQL/Routine/API_C.pod
		lib/SQL/Routine/L/en.pm
		lib/SQL/Routine/Language.pod
		LICENSE
		Makefile.PL
		MANIFEST
		META.yml                                Module meta-data (added by MakeMaker)
		ReadMe
		t/lib/t_SQL_Routine.pm
		t/SQL_Routine.t
		TODO

	* Rewrote the TODO file so it actually lists some near-future plans.

2004-10-04   Darren Duncan <perl@DarrenDuncan.net>

	The next version of the Module List will list the following module:

	  modid:       SQL::Routine
	  DSLIP:       cdpOg
	  description: Specify all database tasks with SQL routines
	  userid:      DUNCAND (Darren Duncan)
	  chapterid:   11 (String_Lang_Text_Proc)
	  enteredby:   BDFOY (brian d foy)
	  enteredon:   Mon Oct  4 20:04:46 2004 GMT

	The resulting entry will be:

	SQL::
	::Routine         cdpOg Specify all database tasks with SQL routines DUNCAND

2004-09-13   Darren Duncan <perl@DarrenDuncan.net>

	* SQL-SyntaxModel-0.42, the last version of the distribution having that
	name which contained the modules that became the SQL-Routine distribution,
	was released on CPAN.

2004-03-22   Darren Duncan <perl@DarrenDuncan.net>

	* SQL-SyntaxModel-0.28, the first version of a distribution having that
	name, was released on CPAN.  Early versions of the modules that became the
	SQL-Routine distribution were included.

2004-03-21   Darren Duncan <perl@DarrenDuncan.net>

	* Rosetta-0.27, the last version of the distribution having that name which
	contained the modules that became the SQL-Routine distribution, was
	released on CPAN.

2003-01-27   Darren Duncan <perl@DarrenDuncan.net>

	* Rosetta-0.02, the first version of a distribution having that name, was
	released on CPAN.  Early versions of the modules that became the
	SQL-Routine distribution were included.

2003-01-05   Darren Duncan <perl@DarrenDuncan.net>

	* DBIx-Portable-0.01, the only version of a distribution having that name,
	was released on CPAN.  Early versions of the modules that became the
	SQL-Routine distribution were included.

2002-11-12   Darren Duncan <perl@DarrenDuncan.net>

	* Began development on the modules which became the SQL-Routine
	distribution as their own entity that is separate from my application, for
	open-source distribution on CPAN.  The modules were to comprise an
	RDBMS-generic DB framework for any application to use.

	* Modules based on a template created by h2xs 1.18.

2002-07-28

	* Posted the first significant update to the second prototype, which added
	an index or cache for data that was expensive to calculate for each page
	request, and involved rewriting about a fourth of the perl code.

2002-06-07

	* Posted to my website the second public prototype demo of the new
	self-proprietary database driven application, whose database schema, user
	interface, feature set, and Perl application code was almost completely
	rewritten. The new version explicitly had separate modules for database
	communication and the web interface logic, with MySQL-specific code and
	database generic or data dictionary code in separate files, and separate
	files for parts of the web interface.  The program used the same generic
	CPAN modules as in the first prototype, DBI/MySQL and CGI::Portable.

2001-11-24

	* Posted the last update to the first prototype.

2001-07-12

	* Posted to my website the first public prototype demo of a new
	self-proprietary database driven application, which is like a cross between
	a multimedia metadata catalogue and a repository for historical or
	genealogical data.  This application contained the first prototypes of code
	that ended up in these modules.  All of this application's code, for
	database communication and web interface logic, was situated in a single
	module, with the rest of the program being more generic CPAN modules like
	DBI (and DBD for MySQL) and CGI::Portable.

2000-05-17

	* Requested MySQL database privileges on my web host so I have something to
	start developing, testing and deploying database driven applications on.
